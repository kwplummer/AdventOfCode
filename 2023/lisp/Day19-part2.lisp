(ql:quickload '(:str :cl-ppcre :hu.dwim.defclass-star))
(defpackage :advent (:use :cl :cl-ppcre :hu.dwim.defclass-star))
(in-package :advent)
(defclass* rule () (name rules))

(defun parse-rule (line)
  (let* ((parts (str:split "{" (str:substring 0 -1 line)))
         (name (first parts))
         (rule-text (str:split "," (second parts)))
         (rules (mapcar (lambda (r) (str:split ":" r)) rule-text)))
    (loop with parsed-rules = (list)
          for rule in rules
          if (= 1 (length rule)) do (push (list nil nil nil (first rule)) parsed-rules)
          else do (register-groups-bind (slot comparison value) ("(\\w+)([<>])(\\w+)" (first rule))
                    (push (list (char slot 0) (char comparison 0) (parse-integer value) (second rule)) parsed-rules))
          finally (return (make-instance 'rule :name name :rules (nreverse parsed-rules))))))

(defun traverse-rule (rules rule-name ranges)
  (when (equal rule-name "R") (return-from traverse-rule 0))
  (when (equal rule-name "A") (return-from traverse-rule
                                (reduce #'* (mapcar (lambda (r)
                                                      (if (zerop (car r)) (cdr r) (1+ (- (cdr r) (car r)))))
                                                    ranges))))
  (loop with out = 0
        for (slot comparison value destination) in (rules-of (gethash rule-name rules))
        for range-index = (position slot '(#\x #\m #\a #\s NIL))
        for (min . max) = (nth range-index ranges)
        if (not slot) do (return (+ out (traverse-rule rules destination ranges)))
        if (char= comparison #\<)
            do (when (< value max) (let ((sub-ranges (copy-list ranges)))
                                     (setf (nth range-index sub-ranges) (cons min (1- value)))
                                     (incf out (traverse-rule rules destination sub-ranges))
                                     (setf (nth range-index ranges) (cons value max))))
        else if (char= comparison #\>)
               do (when (> value min) (let ((sub-ranges (copy-list ranges)))
                                        (setf (nth range-index sub-ranges) (cons (1+ value) max))
                                        (incf out (traverse-rule rules destination sub-ranges))
                                        (setf (nth range-index ranges) (cons min value))))
        finally (return out)))

(defun part-2 (file)
  (let* ((instructions (str:split frog:+double-newline+ file))
         (rules-by-name (serapeum:dict)))
    (loop for rule in (mapcar #'parse-rule (str:lines (first instructions)))
          do (setf (gethash (name-of rule) rules-by-name) rule))
    (traverse-rule rules-by-name "in" (list (cons 0 4000) (cons 0 4000) (cons 0 4000) (cons 0 4000)))))
(print (time (part-2 (frog:get-advent-of-code-input 2023 19))))
