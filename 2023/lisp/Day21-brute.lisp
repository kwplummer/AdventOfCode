(ql:quickload '(:str :cl-ppcre :binding-arrows :hu.dwim.defclass-star :alexandria :parseq :metabang-bind :fset :priority-queue :cl-tqdm :function-cache :lparallel))
(defpackage :advent (:use :cl :cl-ppcre :binding-arrows :parseq :metabang-bind :hu.dwim.defclass-star))
(in-package :advent)
(setf lparallel:*kernel* (lparallel:make-kernel 16))
(declaim (optimize (speed 0) (safety 3) (debug 3) (space 0) (compilation-speed 0)))

(defclass* walker () (x y))
(defun walker-equalp (a b) (and (equal (x-of a) (x-of b)) (equal (y-of a) (y-of b))))
(defmethod print-object ((walker walker) stream)
  (format stream "(~a ~a)" (y-of walker) (x-of walker)))

(defun walk (walker map)
  (with-slots (x y) walker
    (setf (gethash (list y x) map) #\.)
    (if (equal #\. (gethash (list (1+ y) x) map))
        (setf (gethash (list (1+ y) x) map) (make-instance 'walker :x x :y (1+ y))))
    (if (equal #\. (gethash (list (1- y) x) map))
        (setf (gethash (list (1- y) x) map) (make-instance 'walker :x x :y (1- y))))
    (if (equal #\. (gethash (list y (1+ x)) map))
        (setf (gethash (list y (1+ x)) map) (make-instance 'walker :x (1+ x) :y y)))
    (if (equal #\. (gethash (list y (1- x)) map))
        (setf (gethash (list y (1- x)) map) (make-instance 'walker :x (1- x) :y y)))))

(defun parse-map (input)
  (loop with out = (serapeum:dict)
        with lines = (str:lines input)
        for y from 0 below (length lines)
        for line = (nth y lines)
        do (loop for x from 0 below (length line)
                 for char = (char line x)
                 if (equal #\S char) do (setf (gethash (list y x) out) (make-instance 'walker :x x :y y))
                 else do (setf (gethash (list y x) out) char))
        finally (return out)))

(defun print-map (map)
    (loop with max-x = (apply #'max (loop for key being the hash-keys of map collect (second key)))
            with max-y = (apply #'max (loop for key being the hash-keys of map collect (first key)))
            for y from 0 below (1+ max-y)
            do (loop for x from 0 below (1+ max-x)
                     do (format t "~a" (gethash (list y x) map)))
            do (format t "~%")))

(defun part-1 (file steps)
  (loop with map = (parse-map file)
        for i from 0 below steps
        for walkers = (remove-if-not #'walkerp (alexandria:hash-table-values map))
        do (format t "~a: ~a~%" i (length walkers))
        do (loop for walker in walkers
                 do (walk walker map))
        finally (return (length (remove-if-not #'walkerp (alexandria:hash-table-values map))))))

(print (time (part-1 (frog:get-advent-of-code-input 2023 21 :input-suffix "test") 6)))
(print (time (part-1 (frog:get-advent-of-code-input 2023 21) 64)))

(defun walk-p2 (walker map max-y max-x)
  (with-slots (x y) walker
    (let ((up (gethash (list (mod (1- y) max-y) x) map))
          (down (gethash (list (mod (1+ y) max-y) x) map))
          (left (gethash (list y (mod (1- x) max-x)) map))
          (right (gethash (list y (mod (1+ x) max-x)) map))
          (out (list)))
      (if (equal #\. up)
          (push (make-instance 'walker :x x :y (1- y)) out))
      (if (equal #\. down)
          (push (make-instance 'walker :x x :y (1+ y)) out))
      (if (equal #\. left)
          (push (make-instance 'walker :x (1- x) :y y) out))
      (if (equal #\. right)
          (push (make-instance 'walker :x (1+ x) :y y) out))
      out)))

(defun parse-map-2 (input)
  (let* ((map (parse-map input))
         (walker (first (remove-if-not #'walkerp (alexandria:hash-table-values map)))))
    (setf (gethash (list (y-of walker) (x-of walker)) map) #\.)
    (list walker map)))

(defun part-2 (file steps)
  (loop with progress = (cl-tqdm:tqdm steps "")
        with (walker map) = (parse-map-2 file)
        with max-y = (1+ (apply #'max (loop for key being the hash-keys of map collect (first key))))
        with max-x = (1+ (apply #'max (loop for key being the hash-keys of map collect (second key))))
        with walkers = (list walker)
        for i from 0 below steps
        do (setf walkers (remove-duplicates (reduce #'append (mapcar (lambda (walker) (walk-p2 walker map max-y max-x)) walkers)) :test #'walker-equalp))
        do (cl-tqdm:update progress)
        do (format t " ~a: ~a~%" i (length walkers))
        finally (return (length walkers))))
;;(print (time (part-2 (frog:get-advent-of-code-input 2023 21 :input-suffix "test") 6)))
;;(print (time (part-2 (frog:get-advent-of-code-input 2023 21 :input-suffix "test") 10)))
;;(print (time (part-2 (frog:get-advent-of-code-input 2023 21 :input-suffix "test") 50)))
;;(print (time (part-2 (frog:get-advent-of-code-input 2023 21 :input-suffix "test") 100)))
;;(print (time (part-2 (frog:get-advent-of-code-input 2023 21 :input-suffix "test") 500)))
;;(print (time (part-2 (frog:get-advent-of-code-input 2023 21 :input-suffix "test") 5000)))
;;(print (time (part-2 (frog:get-advent-of-code-input 2023 21) 26501365)))
