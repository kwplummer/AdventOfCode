(ql:quickload '(:str :cl-ppcre :binding-arrows :hu.dwim.defclass-star :alexandria :parseq :metabang-bind :fset :priority-queue))
(defpackage :advent (:use :cl :cl-ppcre :binding-arrows :parseq :metabang-bind :hu.dwim.defclass-star))
(in-package :advent)

(defclass* node () (char x y (in-flood nil) (valid t) (listed-neighbors (list)) (neighbors (list))))
(defmethod print-object ((node node) stream)
  (print-unreadable-object (node stream :type t :identity t)
    (format stream "~A ~A ~A ~A" (char-of node) (y-of node) (x-of node)
            (loop for neighbor in (neighbors-of node)
                  collect (list (y-of neighbor) (x-of neighbor))))))

(defun accepts-left (char) (member char '(#\- #\J #\7 #\S)))
(defun accepts-right (char) (member char '(#\- #\F #\L #\S)))
(defun accepts-up (char) (member char '(#\| #\J #\L #\S)))
(defun accepts-down (char) (member char '(#\| #\F #\7 #\S)))

(defun make-network (file)
  (let ((network (serapeum:dict))
        (start nil)
        (lines (str:lines file)))
    (labels ((char-at (y x)
               (if (and (>= y 0) (< y (length lines))
                        (>= x 0) (< x (length (nth y lines))))
                   (char (nth y lines) x)
                   #\space)))

      (loop for y from 0 below (length lines)
            for line = (nth y lines)
            do (loop for x from 0 below (length line)
                     for node = (make-instance 'node :x x :y y :char (char line x))
                     for char = (char line x)
                     do (case char
                          ((#\|) (setf (gethash (list y x) network) node)
                           (if (accepts-down (char-at (- y 1) x))
                               (push (list (- y 1) x) (slot-value node 'listed-neighbors)))
                           (if (accepts-up (char-at (+ y 1) x))
                               (push (list (+ y 1) x) (slot-value node 'listed-neighbors))))
                          (push (list (+ y 1) x) (slot-value node 'listed-neighbors))
                          ((#\-) (setf (gethash (list y x) network) node)
                           (if (accepts-right (char-at y (- x 1)))
                               (push (list y (- x 1)) (slot-value node 'listed-neighbors)))
                           (if (accepts-left (char-at y (+ x 1)))
                               (push (list y (+ x 1)) (slot-value node 'listed-neighbors))))
                          ((#\L) (setf (gethash (list y x) network) node)
                           (if (accepts-down (char-at (- y 1) x))
                               (push (list (- y 1) x) (slot-value node 'listed-neighbors)))
                           (if (accepts-left (char-at y (+ x 1)))
                               (push (list y (+ x 1)) (slot-value node 'listed-neighbors))))
                          ((#\J) (setf (gethash (list y x) network) node)
                           (if (accepts-down (char-at (- y 1) x))
                               (push (list (- y 1) x) (slot-value node 'listed-neighbors)))
                           (if (accepts-right (char-at y (- x 1)))
                               (push (list y (- x 1)) (slot-value node 'listed-neighbors))))
                          ((#\7) (setf (gethash (list y x) network) node)
                           (if (accepts-up (char-at (+ y 1) x))
                               (push (list (+ y 1) x) (slot-value node 'listed-neighbors)))
                           (if (accepts-right (char-at y (- x 1)))
                               (push (list y (- x 1)) (slot-value node 'listed-neighbors))))
                          ((#\F) (setf (gethash (list y x) network) node)
                           (if (accepts-up (char-at (+ y 1) x))
                               (push (list (+ y 1) x) (slot-value node 'listed-neighbors)))
                           (if (accepts-left (char-at y (+ x 1)))
                               (push (list y (+ x 1)) (slot-value node 'listed-neighbors))))
                          ((#\.) (setf (gethash (list y x) network) node))
                          ((#\S) (setf (gethash (list y x) network) node)
                           (setf start node)))))
      ;; Expand all neighbors
      (loop for node being the hash-values of network
            do (loop for neighbor-coords in (slot-value node 'listed-neighbors)
                     for neighbor = (gethash neighbor-coords network)
                     when neighbor do (progn (push neighbor (slot-value node 'neighbors))
                                             (push node (slot-value neighbor 'neighbors))))
            finally (loop for node being the hash-values of network
                          do (setf (slot-value node 'neighbors) (remove-duplicates (slot-value node 'neighbors) :test #'equal))))
      (values start network))))

(defun traverse (node visited max)
  (format t "Traversing ~A, was-visisted: ~A, max: ~A~%" node (member node visited) max)
  (when (member node visited) (return-from traverse max))
  (push node visited)
  (loop for neighbor in (neighbors-of node)
        maximizing (traverse neighbor visited (1+ max))))

(defun get-loop (start)
  (let* ((min-distance (serapeum:dict))
         (best-distance most-positive-fixnum)
         (queue (priority-queue:make-pqueue #'<)))
    (setf (gethash start min-distance) 0)
    (priority-queue:pqueue-push (list 0 start) 0 queue)
    (loop until (priority-queue:pqueue-empty-p queue)
          for next = (priority-queue:pqueue-pop queue)
          for dist = (first next)
          for node = (second next)
          for neighbors = (neighbors-of node)
          do (loop with new-distance = (1+ dist)
                   for neighbor in neighbors
                   for old-distance = (gethash neighbor min-distance best-distance)
                   if (< new-distance old-distance)
                     do (setf (gethash neighbor min-distance) new-distance)
                        (priority-queue:pqueue-push (list new-distance neighbor) new-distance queue))
          finally (return min-distance))))

(defun part-1 (file)
  (let* ((start (make-network file))
         (pipe-loop (get-loop start)))
    (reduce #'max (alexandria:hash-table-values pipe-loop))))

;; (print (make-network (frog:get-advent-of-code-input 2023 10 :input-suffix "test2")))
(print (time (part-1 (frog:get-advent-of-code-input 2023 10))))

(defun part-2 (file)
  (multiple-value-bind (start network) (make-network file)
    (let* ((loop-nodes (alexandria:hash-table-keys (get-loop start)))
           (loop-locs (mapcar (lambda (n) (list (y-of n) (x-of n))) loop-nodes))
           (max-x (reduce #'max (mapcar #'x-of (alexandria:hash-table-values network))))
           (max-y (reduce #'max (mapcar #'y-of (alexandria:hash-table-values network)))))
      (loop for node in loop-nodes do (setf (valid-of node) nil))
      (loop for location being the hash-keys of network using (hash-value node)
            for x = (second location) and y = (first location)
            when (not (member node loop-nodes))
              do (loop for y-beam from y downto 0
                       when (member (list y-beam x) loop-locs :test #'equal) do (return)
                         when (= y-beam 0) do (setf (valid-of node) nil))
                 (loop for y-beam from y upto max-y
                       when (member (list y-beam x) loop-locs :test #'equal) do (return)
                         when (= y-beam max-y) do (setf (valid-of node) nil))
                 (loop for x-beam from x downto 0
                       when (member (list y x-beam) loop-locs :test #'equal) do (return)
                         when (= x-beam 0) do (setf (valid-of node) nil))
                 (loop for x-beam from x upto max-x
                       when (member (list y x-beam) loop-locs :test #'equal) do (return)
                         when (= x-beam max-x) do (setf (valid-of node) nil))
            finally (format t "Valid nodes: ~A~%" (remove-if-not #'valid-of (alexandria:hash-table-values network)))
                    (return (count-if #'valid-of (alexandria:hash-table-values network)))))))


(print (part-2 (frog:get-advent-of-code-input 2023 10 :input-suffix "test3"))) ;; 4
;; (print (make-network (frog:get-advent-of-code-input 2023 10 :input-suffix "test4"))) ;; 8
;; (print (make-network (frog:get-advent-of-code-input 2023 10 :input-suffix "test5"))) ;; 10

;; (print (time (traverse (make-network (frog:get-advent-of-code-input 2023 10 :input-suffix "test")) nil 0)))
