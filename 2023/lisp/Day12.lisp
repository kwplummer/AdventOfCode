(ql:quickload '(:str :function-cache))
(defpackage :advent (:use :cl))
(in-package :advent)
(declaim (optimize (speed 3) (safety 0) (debug 0) (compilation-speed 0)))
(defun 5x (input delimiter) (str:join delimiter (make-list 5 :initial-element input)))
(defun subseq-safe (sequence start &optional end)
  (subseq sequence (min (length sequence) start) (min (length sequence) (or end (length sequence)))))

(defun is-valid (line groups)
  (if (and (null groups) (str:contains? "#" line)) nil
      (let ((split (remove-if #'str:emptyp (str:split "." line))))
        (if (/= (length split) (length groups)) nil
            (loop with split = (remove-if #'str:emptyp (str:split "." line))
                  for i from 0 below (length split)
                  if (or (>= i (length groups))
                         (/= (length (nth i split)) (nth i groups))) do (return nil)
                  finally (return t))))))

(function-cache:defcached (permute-line :cache-class function-cache:lru-cache :capacity 100000) (line groups)
  (setf line (string-trim "." line))
  (let ((pos (position #\? line)))
    (if (null pos) (if (is-valid line groups) 1 0)
        (loop for attempt in (list #\# #\.)
              for should-recurse = t
              for new-groups = groups and new-line = (copy-seq line)
              do (setf (char new-line pos) attempt)
                 (when (or (and (eql attempt #\.) (str:starts-with-p "#" (string-left-trim "." new-line)))
                           (and (eql attempt #\#) (equal (str:s-nth (1+ pos) new-line) ".")))
                   (let* ((possible-line (str:substring 0 (1+ pos) new-line))
                          (possible-groups (subseq-safe new-groups 0 (length (remove-if #'str:emptyp (str:split "." possible-line))))))
                     (if (is-valid possible-line possible-groups)
                         (setf new-line (str:substring (1+ pos) nil new-line)
                               new-groups (subseq-safe new-groups (length possible-groups)))
                         (setf should-recurse nil))))
              if should-recurse sum (permute-line new-line new-groups)))))

(defun part-1 (file)
  (loop for input in (str:lines file)
        for (line text-groups) = (str:split " " input)
        for groups = (mapcar #'parse-integer (str:split "," text-groups))
        sum (permute-line line groups)))
(print (time (part-1 (frog:get-advent-of-code-input 2023 12))))

(defun part-2 (file)
  (loop for input in (str:lines file)
        for (line text-groups) = (str:split " " input)
        for line-5x = (5x line "?")
        for groups-5x = (mapcar #'parse-integer (str:split "," (5x text-groups ",")))
        sum (permute-line line-5x groups-5x)))
(print (time (part-2 (frog:get-advent-of-code-input 2023 12))))
